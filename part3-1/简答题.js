/*当我们点击按钮的时候动态给data增加的成员是否是响应式数据，
 如果不是的话，如何把新增成员设置成响应式数据，它的内部原理是什么。

 let  vm = new Vue({
     el:'#el',
     data:{
         o:'object',
         dog:{}
     },
     method:{
         clickHander(){
            this.dog.name ='Trump'
         }
     }
 })

 答：不是响应式的，装换成响应式数据是在创建vue实例化的时候，实例化结束后新增成员只是
 新添加了一个属性，如果需要把新增成员设置成响应式的
   可以使用  Vue.set(object,properyName,value)的方法向对象添加响应式属性
   但是不允许动态添加根级别的响应式属性。
   内部原理是调用object.defineProperty 将该属性装换成响应式数据
*/


/* 简述Diff算法的执行过程
   diff算法：判断子节点是否有变化(直接写同层级比较)
     1.初始化变量，记录新旧开始和结束索引，以及对应的节点等
     2.while循环比较新旧节点
     3.判断索引对应的节点是否存在，如果不存在则改变索引直到对应节点存在

     4.1旧开始节点和新开始节点的比较：比较并更新差异，索引后移，重新赋值新旧开始节点，进行下一轮比较
     4.2旧结束节点和新结束节点的比较：比较并更新差异，索引前移，重新赋值新旧结束节点，进行下一轮比较
     4.3旧开始节点和新结束节点的比较：比较并更新差异，把旧的开始节点移动到旧的结束节点之后，并移动索引，旧开始节点索引后移，新结束节点索引前移，重新赋值旧开始节点和新结束节点，开始下一轮比较
     4.4旧结束节点和新开始节点的比较：比较并更新差异，把
     旧的结束节点移动旧的开始节点之前，并移动索引，旧的结束节点索引前移，新的开始节点索引前移，重新赋值旧结束节点和新开始节点，进行下一轮比较
     
     4.5使用新开始节点的key值在老节点数组中找是否有相同节点
        4.5.1. 先获取老节点书中当前没有遍历的节点key和其索引的对应关系
        4.5.2. 如果当前还未获得这个关系则进行初始化
        4.5.3.  createKeyToOldIdx(oldCh,oldStartIdx,oldEndIdx)
        这个函数接收三个参数，第一个参数是当前老节点的数组，以及当前老节点未进行遍历的节点的开始索引和结束索引，如果该节点的key存在则记录到map对象中，把当前的key值作为key，当前节点对应的下标作为key对应的值，记录所有未遍历的节点的key和索引关系并返回
        4.5.4.根据新开始节点的key值在当前map中查找是否存在相同key值得节点，如果没有找到，那么新开始节点是一个新节点，创建该节点对应的don元素并插入到旧开始节点之前，新开始节点索引后移，重新赋值，进行下一轮的判断
        如果找到了相同key值的老节点，从老节点数组中根据下标获取到当前老节点，如果两个节点的选择器不同，那么说明不是同一个节点，需要创建新开始节点对应的的dom 元素，插入到旧开始节点之前，新开始节点索引后移，重新赋值，进行下一轮的判断
        如果是相同的节点则进行patch比较并更新差异，将旧节点元素移到旧开始节点的前面，将移动走的老节点的位置设置为undefined
     
    5.新旧节点数组 中有一组遍历结束
    6.判断新旧节点数组是否有多余的节点需要处理
      如果新节点数组先遍历完成，说明老节点数组存在多余的节点需要删除，如果旧节点数组先遍历完成，说明老节点数组还要添加节点元素，在对应的位置进行处理
*/ 